### 树状数组这种数据结构有什么意义？
- 假设一个数组只需要有两种操作：**1、查找某个位置的元素**  **2、计算前n个元素的和**
- 如果数组过于庞大（例如有百万级别的元素），**操作1**的时间复杂度为O(1)，而**操作2**的时间复杂度为O(n)。一方面求和操作会过于耗费时间，另一方面两种操作的时间消耗极不对等
- 因此，有没有一种方法可以降低操作2的时间复杂度呢？
  - 有的兄弟有的，这种方法就是采用树状树这种数据结构！
  - 先说结论：树状数可以将操作2的时间复杂度降低为O(log n)级别。但作为代价，操作1的复杂度（即查询复杂度）会提升至O(log n)。
  - 从某种角度来讲，这样即均衡了两种操作的执行效率，同时也大幅提升了操作2的效率，确实有其nb之处
### 树状数组长什么样？
- 如图：
  - <img src="https://img-blog.csdnimg.cn/0f4d37bbe0db4b5a8e2d135f9561af77.png" alt="树状数组" width="500px" height="300px">
- 树状数组t由原始数组a演变而来
  - 树中的每一个节点都对应着原始数组a中某一段区间的和，这段区间的长度为2的幂次方（2^i = 1,2,4,8,……）
  - 如果已有一个树状数组t，我们怎么知道其中每个元素对应区间长度，以及在原始数组a哪个位置上呢（起止坐标）？这是个好问题。
    - 我们先来介绍一个函数：lowbit(n)。这个函数只有一行代码，很简单但是也很抽象。本质上是通过，符号取反的有符号整数的补码形式与原数字按位与，求得原整数最低位1与后续0所代表的十进制数。e.g. lowbit(6)==2   lowbit(10)==2
``` CXX
int lowbit(n){
  return n & -n; // 当n == 10时， 'b001010 & 'b110110 == 'b000010 == 'd2
}
```
