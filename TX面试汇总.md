## 学习记录
- `C++`中`dynamic_cast`和`static_cast`的区别是什么？
  - `static_cast`，**基本数据类型转换**，子对象转父对象（向上），或**非多态类**向下转换
  - `dynamic_cast`，常用于**多态类**父对象转子对象（**向下**，且必须是多态类型），可在运行时**自动检测类型兼容**性。如果转换失败会返回`nullptr`或抛出异常。具体来说，`dynamic_cast`的运行时自动类型检查是基于`RTTI（Run-Time Type Information）`。包含虚函数的类对象在创建时会隐含一个指向虚函数表（vtable）的虚函数指针（vptr）。`vtable`中存储了`RTTI`，其中包含类名，继承关系等元数据。当程序运行到`dynamic_cast<目标类型>(表达式)`时，通过对象的虚函数表访问`RTTI`检查目标类型是否是当前类型合法的派生类、基类或同类。若合法则返回调整后的指针（可能会因多重继承调整），否则错误处理。
- 对多态的理解？
  - 多态在我的理解上是，同一事物表现出不同行为的现象
  - 在C++常被用于类行为（虚函数与继承，运行时多态， `override`）与普通函数行为（重载，编译时多态，`overload`）
  - 对有多态性质的类来讲，多态的核心思想是 “通过统一的接口操作不同的对象”。具体来说是，能通过基类接口访问子类方法。有多态性质的类的析构函数一定要是虚函数，构造函数一定不能是虚函数。
  - 再提一嘴，纯虚函数（即，`virtual void draw() const = 0;`）**必须重写**，因为其只有接口没有实现。`= default`是说使用**默认**的函数功能。`= delete`是说显示**禁用**某个函数或方法。
- `C++`程序编译后包含哪些内存段？虚函数表属于哪个段？
  - 老生常谈，从下往上：代码段、常量段（.rodata，存字符串常量、虚函数表等）、数据段（.data）、BSS段、堆（由下向上）、文件映射段（由上向下）、栈（由上向下）、命令行参数与环境变量、内核空间（用+内 win:2+2GB、linux:3+1GB）
  - 虚函数表，在编译时由编译器生成，其内容（虚函数指针）是静态且只读的。在GCC中通常存放在只读数据段（`.rodata`）
- 右值引用的特性是什么？应用场景有哪些？
  - 特性：
    - 语法：`int &&ref = 10`
    - 绑定对象：只能绑定右值，如临时对象、字面量、函数返回值等
    - 转移方式：将资源的**管理权**从右值“转移”到新对象，避免不必要的复制。
  - 应用场景：移动语义（`std::move()`，用于回调函数移动、独占指针所有权移动等）、完美转发等
## 3.6 一面
### 一、自我介绍
### 二、介绍一下Python上位机项目
###  三、介绍一下`static`关键字
- 在 C++ 中的作用，在哪个内存空间？
- 如果在一个头文件中声明并定义了一个`static`全局变量，会有什么问题？
### 四、进程与线程
- 进程中的地址空间分为哪些区域？
- 堆内存一般如何分配，有哪些注意事项？
- 不同线程共享进程的哪些空间？自己独立的空间有哪一些？
- 多个线程访问进程的共享资源时有什么注意事项？一点要加锁吗？如果是单一生产者，单一消费者模型？
###  五、智能指针
- 有哪些智能指针？作用是什么？
- 底层如何实现对指针的自动释放？
###  六、手撕1：
- 判断以下输出结果（8 8 16）：
```CXX
class A1 {
		virtual int testA1() {};
	};
	class A2 {
		virtual int testA2() {};
	};

	class B : public A1,A2 {
		virtual int testA1() override {};
		virtual int testA2() {};
	};

	cout << "sizeof(A1): " << sizeof(A1) << " sizeof(A2):" << sizeof(A2) << " sizeof(B):" << sizeof(B) << endl;
```
###  七、手撕2：
- 最长递增子序列（不要求连续）：动态规划
###  八、手撕3：
- 计算二叉树的最大深度：层序遍历计算层数、后序递归遍历（返回以当前节点为根结点的树的最大深度）
###  九、手撕4：
- 按照计算器逻辑计算一串字符串的值，e.g. `1 + 2 * (5 + 60) + 2 * 4 + 5`
###  十、介绍一下左值与右值的区别
- xixi，刚想起来
